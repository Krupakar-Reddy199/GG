{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;\red255\green0\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\par
\par
{{\field{\*\fldinst{HYPERLINK https://gemini.google.com/app/b821f33121f3fccf }}{\fldrslt{https://gemini.google.com/app/b821f33121f3fccf\ul0\cf0}}}}\f0\fs22\par
\par
\par
Bidirectional (Active-Active) replication in Oracle GoldenGate is a sophisticated setup where two or more databases simultaneously process transactions and replicate those changes to each other, keeping all instances synchronized. This configuration provides high availability, disaster recovery, and workload balancing, as users can connect to any of the active databases.\par
\par
However, active-active replication introduces unique challenges, primarily data conflicts and data looping, which must be carefully addressed for successful implementation.\par
\par
Key Challenges and Solutions in Bidirectional Replication:\par
\par
Data Looping Prevention:\par
\par
Problem: If a transaction originates on Database A, replicates to Database B, and then Database B's Extract captures that same transaction and replicates it back to Database A, an infinite loop of replication occurs.\par
Solution: Oracle GoldenGate provides mechanisms to prevent this:\par
TRANLOGOPTIONS EXCLUDEUSER <GGUSER>: This is the most common and effective method. In the Extract parameter file on each database, you specify the GoldenGate database user that the Replicat process on that same database uses. This tells the Extract process to ignore transactions generated by its own Replicat.\par
TRANLOGOPTIONS EXCLUDEUSERID <USERID>: Similar to EXCLUDEUSER, but uses the numeric user ID.\par
SETTAG and GETAPPLOPS/IGNOREREPLICATES:\par
SETTAG (Replicat parameter): Replicat can set a tag in the redo log when it applies a transaction. This tag can then be used by the Extract process on the same database to identify and exclude those tagged transactions.\par
GETAPPLOPS/IGNOREREPLICATES (Extract parameters): These parameters control whether Extract captures or ignores DML operations produced by the local Replicat. IGNOREREPLICATES is often used in conjunction with SETTAG.\par
Conflict Detection and Resolution (CDR):\par
\par
Problem: In an active-active environment, the same row in two different databases might be updated, inserted, or deleted concurrently before the changes are replicated. This leads to data inconsistencies.\par
INSERTROWEXISTS: An attempt to insert a row, but a row with the same primary key already exists at the target.\par
UPDATEROWMISSING: An attempt to update a row, but the row is not found at the target.\par
UPDATEROWEXISTS: An attempt to update a row, but the "before image" of the row in the trail file does not match the actual row in the target database, indicating a concurrent update.\par
DELETEROWMISSING: An attempt to delete a row, but the row is not found at the target.\par
DELETEROWEXISTS: An attempt to delete a row, but the "before image" of the row in the trail file does not match the actual row in the target database, indicating a concurrent update before deletion.\par
Solutions:\par
Automatic Conflict Detection and Resolution (ACDR): Available with Oracle Database (since 12.1 and enhanced in later versions). This is the recommended approach as it's built into the database and highly efficient.\par
How it works: ACDR automatically adds a hidden timestamp column ($OGG_ROW_TIMESTAMP) to tables and uses it to resolve conflicts based on the latest timestamp.\par
Enabling ACDR:\par
SQL\par
\par
EXEC DBMS_GOLDENGATE_ADM.ADD_AUTO_CDR(\par
    schema_name => 'YOUR_SCHEMA',\par
    table_name => 'YOUR_TABLE',\par
    RECORD_CONFLICTS => TRUE -- Optional, to record conflicts in a log table\par
);\par
The MAPINVISIBLECOLUMNS and LOGALLSUPPCOLS parameters are crucial in Extract for ACDR.\par
Replicat should typically be Integrated Replicat or Parallel Replicat in integrated mode.\par
Manual Conflict Detection and Resolution (COMPARECOLS, RESOLVECONFLICT): For older GoldenGate versions or specific complex scenarios, you can define explicit rules in the Replicat parameter file.\par
COMPARECOLS: Specifies which columns to compare in the before image to detect conflicts (e.g., ON UPDATE ALL, ON DELETE ALL).\par
RESOLVECONFLICT: Defines the resolution strategy for different conflict types. Common resolution types include:\par
USEMAX/USEMIN: Use the row with the maximum or minimum value of a specific column (e.g., a timestamp column).\par
OVERWRITE: Always apply the incoming change, overwriting the target.\par
DISCARD: Discard the incoming change (log to discard file).\par
IGNORE: Ignore the conflict (continue processing).\par
USEDETAIL: For numeric columns, add/subtract a delta.\par
Example RESOLVECONFLICT for INSERTROWEXISTS:\par
MAP schema.table, TARGET schema.table,\par
RESOLVECONFLICT (INSERTROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TIME)));\par
Best Practice: Design your application and database schema to minimize conflicts.\par
Primary Keys: Ensure all replicated tables have primary keys.\par
Timestamp Column: Add a TIMESTAMP WITH LOCAL TIME ZONE column to all replicated tables, populated by a trigger (excluding the GoldenGate user) or application logic on DML operations. This column is essential for timestamp-based conflict resolution (USEMAX/USEMIN).\par
Partitioning Data: If possible, segment data or operations by geography, customer ID ranges, etc., to minimize concurrent updates on the same rows.\par
Sequences: Sequences are not directly supported for bidirectional replication. You need to implement strategies like:\par
Odd/Even sequences: One site uses odd numbers, the other even.\par
Range-based sequences: Each site has a dedicated range of sequence numbers.\par
Global sequence generation: A central service generates sequence numbers.\par
Triggers: Triggers can cause issues. Use DBOPTIONS SUPPRESSTRIGGERS in Replicat to prevent triggers from firing on replicated transactions, or ensure triggers are idempotent.\par
TRUNCATE: TRUNCATE operations are typically not included in conflict detection. It's often recommended to only allow TRUNCATE from one site or handle it carefully with specific Extract/Replicat parameters (GETTRUNCATES, IGNOREROWS).\par
High-Level Steps for Bidirectional Replication (Active-Active):\par
\par
The general steps for setting up bidirectional replication are similar to unidirectional, but you configure both databases as source and target, with additional parameters to handle looping and conflicts.\par
\par
Assumptions:\par
\par
DBA1 and DBA2 are the two Oracle databases.\par
HostA and HostB are the respective servers.\par
gguser is the GoldenGate user on both databases.\par
I. Prerequisites (On both DBA1 and DBA2)\par
\par
Database Configuration:\par
ARCHIVELOG mode, FORCE LOGGING, SUPPLEMENTAL LOG DATA (minimum and often ALL for columns used in CDR).\par
ALTER SYSTEM SET ENABLE_GOLDENGATE_REPLICATION=TRUE SCOPE=BOTH;\par
GoldenGate User and Privileges: Create gguser and grant necessary privileges as in unidirectional setup.\par
GoldenGate Installation and Subdirectories: Install GG binaries and CREATE SUBDIRS.\par
Manager Process: Configure and start MGR on both HostA and HostB.\par
II. Configuration on DBA1 (HostA)\par
\par
DBLOGIN: DBLOGIN USERID gguser, PASSWORD gguser\par
Checkpoint Table: ADD CHECKPOINTTABLE gguser.chkpt (Crucial for Replicat recovery)\par
Supplemental Logging (TRANDATA/SCHEMATRANDATA):\par
GGSCI> ADD SCHEMATRANDATA schema_name ALLCOLS; -- ALLCOLS is important for CDR\par
Primary Extract (EXT1_A): Captures changes from DBA1.\par
GGSCI> EDIT PARAMS EXT1_A\par
EXTRACT EXT1_A\par
USERID gguser, PASSWORD gguser\par
EXTTRAIL ./dirdat/aa\par
DDL INCLUDE ALL\par
TRANLOGOPTIONS EXCLUDEUSER gguser # Crucial for loop prevention (EXCLUDE REPLICAT's changes)\par
TABLE schema_name.table_name, GETBEFORECOLS (ON UPDATE ALL, ON DELETE ALL); # Needed for CDR\par
# For Integrated Extract: REGISTER EXTRACT EXT1_A DATABASE\par
GGSCI> ADD EXTRACT EXT1_A, INTEGRATED TRANLOG, BEGIN NOW\par
GGSCI> ADD EXTTRAIL ./dirdat/aa, EXTRACT EXT1_A\par
Data Pump (DP1_A): Sends captured changes from DBA1 to DBA2.\par
GGSCI> EDIT PARAMS DP1_A\par
EXTRACT DP1_A\par
USERID gguser, PASSWORD gguser\par
RMTHOST HostB, MGRPORT 7809\par
RMTTRAIL ./dirdat/ba # Remote trail on HostB for changes from DBA1\par
PASSTHRU # Passes the data directly from the local trail\par
TABLE schema_name.table_name;\par
GGSCI> ADD EXTRACT DP1_A, EXTTRAILSORUCE ./dirdat/aa\par
GGSCI> ADD RMTTRAIL ./dirdat/ba, EXTRACT DP1_A\par
Replicat (REP1_B): Applies changes from DBA2 to DBA1.\par
GGSCI> EDIT PARAMS REP1_B\par
REPLICAT REP1_B\par
USERID gguser, PASSWORD gguser\par
ASSUMETARGETDEFS\par
DDL INCLUDE ALL\par
DDLOPTIONS REPORT, UPDATEMETADATA # Useful for DDL replication\par
CHECKPOINTTABLE gguser.chkpt\par
DISCARDFILE ./dirrpt/rep1_b.dsc, APPEND, MEGABYTES 100\par
# Conflict Resolution\par
MAP schema_name.table_name, TARGET schema_name.table_name,\par
RESOLVECONFLICT (INSERTROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TIME))),\par
RESOLVECONFLICT (UPDATEROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TIME))),\par
RESOLVECONFLICT (UPDATEROWMISSING, (DEFAULT, DISCARD)),\par
RESOLVECONFLICT (DELETEROWEXISTS, (DEFAULT, OVERWRITE)),\par
RESOLVECONFLICT (DELETEROWMISSING, (DEFAULT, DISCARD));\par
# If using ACDR, instead of manual RESOLVECONFLICT:\par
# MAP schema_name.table_name, TARGET schema_name.table_name, MAPINVISIBLECOLUMNS;\par
\par
GGSCI> ADD REPLICAT REP1_B, INTEGRATED, EXTTRAIL ./dirdat/ab, CHECKPOINTTABLE gguser.chkpt\par
Note: EXTTRAIL ./dirdat/ab here refers to the remote trail file coming from DBA2 to DBA1.\par
III. Configuration on DBA2 (HostB)\par
\par
Steps are symmetrical to DBA1.\par
\par
DBLOGIN: DBLOGIN USERID gguser, PASSWORD gguser\par
Checkpoint Table: ADD CHECKPOINTTABLE gguser.chkpt\par
Supplemental Logging (TRANDATA/SCHEMATRANDATA):\par
GGSCI> ADD SCHEMATRANDATA schema_name ALLCOLS;\par
Primary Extract (EXT2_B): Captures changes from DBA2.\par
GGSCI> EDIT PARAMS EXT2_B\par
EXTRACT EXT2_B\par
USERID gguser, PASSWORD gguser\par
EXTTRAIL ./dirdat/ab\par
DDL INCLUDE ALL\par
TRANLOGOPTIONS EXCLUDEUSER gguser # Crucial for loop prevention\par
TABLE schema_name.table_name, GETBEFORECOLS (ON UPDATE ALL, ON DELETE ALL);\par
# For Integrated Extract: REGISTER EXTRACT EXT2_B DATABASE\par
GGSCI> ADD EXTRACT EXT2_B, INTEGRATED TRANLOG, BEGIN NOW\par
GGSCI> ADD EXTTRAIL ./dirdat/ab, EXTRACT EXT2_B\par
Data Pump (DP2_B): Sends captured changes from DBA2 to DBA1.\par
GGSCI> EDIT PARAMS DP2_B\par
EXTRACT DP2_B\par
USERID gguser, PASSWORD gguser\par
RMTHOST HostA, MGRPORT 7809\par
RMTTRAIL ./dirdat/aa # Remote trail on HostA for changes from DBA2\par
PASSTHRU\par
TABLE schema_name.table_name;\par
GGSCI> ADD EXTRACT DP2_B, EXTTRAILSORUCE ./dirdat/ab\par
GGSCI> ADD RMTTRAIL ./dirdat/aa, EXTRACT DP2_B\par
Replicat (REP2_A): Applies changes from DBA1 to DBA2.\par
GGSCI> EDIT PARAMS REP2_A\par
REPLICAT REP2_A\par
USERID gguser, PASSWORD gguser\par
ASSUMETARGETDEFS\par
DDL INCLUDE ALL\par
DDLOPTIONS REPORT, UPDATEMETADATA\par
CHECKPOINTTABLE gguser.chkpt\par
DISCARDFILE ./dirrpt/rep2_a.dsc, APPEND, MEGABYTES 100\par
# Conflict Resolution\par
MAP schema_name.table_name, TARGET schema_name.table_name,\par
RESOLVECONFLICT (INSERTROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TIME))),\par
RESOLVECONFLICT (UPDATEROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TIME))),\par
RESOLVECONFLICT (UPDATEROWMISSING, (DEFAULT, DISCARD)),\par
RESOLVECONFLICT (DELETEROWEXISTS, (DEFAULT, OVERWRITE)),\par
RESOLVECONFLICT (DELETEROWMISSING, (DEFAULT, DISCARD));\par
# If using ACDR, instead of manual RESOLVECONFLICT:\par
# MAP schema_name.table_name, TARGET schema_name.table_name, MAPINVISIBLECOLUMNS;\par
\par
GGSCI> ADD REPLICAT REP2_A, INTEGRATED, EXTTRAIL ./dirdat/ba, CHECKPOINTTABLE gguser.chkpt\par
Note: EXTTRAIL ./dirdat/ba here refers to the remote trail file coming from DBA1 to DBA2.\par
IV. Start and Monitor Processes\par
\par
Start on HostA:\par
GGSCI> START EXTRACT EXT1_A\par
GGSCI> START EXTRACT DP1_A\par
GGSCI> START REPLICAT REP1_B\par
Start on HostB:\par
GGSCI> START EXTRACT EXT2_B\par
GGSCI> START EXTRACT DP2_B\par
GGSCI> START REPLICAT REP2_A\par
Monitor: Use INFO ALL, STATS <process_name>, and check report and discard files on both sides.\par
V. Initial Data Synchronization (Important!)\par
\par
Before starting live bidirectional replication, you need to ensure the initial data sets are identical.\par
\par
One-time Data Pump (initial load): A common approach is to use a dedicated initial load Extract/Replicat pair from one database to the other to synchronize the data.\par
Database Tools: Use Oracle Data Pump (expdp/impdp) to export data from one database and import it into the other, ensuring a consistent starting point.\par
Important Considerations for Active-Active:\par
\par
Application Design: Applications should ideally be designed to minimize direct conflicts. If conflicts are frequent, active-active might not be the best solution.\par
Latency: While GoldenGate is low-latency, some lag is inherent in asynchronous replication. Applications must tolerate this brief inconsistency.\par
Network: Robust and high-bandwidth network connectivity between the sites is critical.\par
Monitoring and Alerting: Implement comprehensive monitoring to quickly identify and resolve any replication issues or conflicts.\par
DDL Replication: DDL replication in active-active can be complex. While GoldenGate can replicate DDL, there's no built-in DDL conflict resolution. Best practice is to perform DDL changes during maintenance windows from a single designated site.\par
\par
\par
\par
\cf2 ============================================================================\par
\par
\cf0\par
\par
Scenario\par
We have two Oracle databases:\par
\par
DBA1 (on HostA)\par
DBA2 (on HostB)\par
We want to replicate changes for a table named HR.EMPLOYEES bidirectionally between them.\par
\par
1. Database & Schema Preparation (On both DBA1 and DBA2)\par
1.1. SQL (Connect as SYSDBA)\par
\par
SQL\par
\par
-- Ensure ARCHIVELOG mode and Force Logging\par
SHUTDOWN IMMEDIATE;\par
STARTUP MOUNT;\par
ALTER DATABASE ARCHIVELOG;\par
ALTER DATABASE OPEN;\par
ALTER DATABASE FORCE LOGGING;\par
\par
-- Enable supplemental logging at the database level\par
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;\par
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY, UNIQUE INDEX) COLUMNS;\par
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS; -- Recommended for CDR\par
\par
-- Enable GoldenGate replication feature\par
ALTER SYSTEM SET ENABLE_GOLDENGATE_REPLICATION=TRUE SCOPE=BOTH;\par
\par
-- Create GoldenGate user (if not already done)\par
CREATE USER gguser IDENTIFIED BY GgUser123 DEFAULT TABLESPACE users QUOTA UNLIMITED ON users;\par
GRANT CREATE SESSION, CONNECT, RESOURCE, ALTER SYSTEM TO gguser;\par
-- Grant GoldenGate specific privileges\par
EXEC DBMS_GOLDENGATE_AUTH.GRANT_ADMIN_PRIVILEGE(grantee=>'gguser', privilege_type=>'CAPTURE', grant_optional_privileges=>'*');\par
EXEC DBMS_GOLDENGATE_AUTH.GRANT_ADMIN_PRIVILEGE(grantee=>'gguser', privilege_type=>'APPLY', grant_optional_privileges=>'*');\par
1.2. Create HR schema and EMPLOYEES table (On both DBA1 and DBA2)\par
\par
SQL\par
\par
-- Connect as SYSDBA or an admin user\par
CREATE USER hr IDENTIFIED BY HrPassword123 DEFAULT TABLESPACE users QUOTA UNLIMITED ON users;\par
GRANT CREATE SESSION, RESOURCE TO hr;\par
GRANT SELECT ON V_$DATABASE TO hr; -- Needed for TIMESTAMP WITH LOCAL TIME ZONE\par
\par
-- Connect as HR user\par
CONNECT hr/HrPassword123;\par
\par
CREATE TABLE employees (\par
    employee_id    NUMBER(6) PRIMARY KEY,\par
    first_name     VARCHAR2(20),\par
    last_name      VARCHAR2(25) NOT NULL,\par
    email          VARCHAR2(25) NOT NULL UNIQUE,\par
    phone_number   VARCHAR2(20),\par
    hire_date      DATE NOT NULL,\par
    job_id         VARCHAR2(10) NOT NULL,\par
    salary         NUMBER(8,2),\par
    commission_pct NUMBER(2,2),\par
    manager_id     NUMBER(6),\par
    department_id  NUMBER(4),\par
    -- Crucial for conflict resolution: a timestamp for last update\par
    last_update_ts TIMESTAMP(6) WITH LOCAL TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL\par
);\par
\par
-- Create a trigger to update last_update_ts on changes (exclude gguser)\par
CREATE OR REPLACE TRIGGER trg_employees_last_upd\par
BEFORE INSERT OR UPDATE ON employees\par
FOR EACH ROW\par
BEGIN\par
    -- Only update if the user is NOT the GoldenGate user\par
    IF USER != 'GGUSER' THEN\par
        :NEW.last_update_ts := SYSTIMESTAMP;\par
    END IF;\par
END;\par
/\par
\par
-- Grant select on the table to gguser\par
GRANT SELECT, INSERT, UPDATE, DELETE ON employees TO gguser;\par
2. GoldenGate Installation & Setup (On HostA and HostB)\par
2.1. Install GoldenGate binaries.\par
\par
2.2. Create Subdirectories (in GGSCI on both hosts)\par
\par
GGSCI> CREATE SUBDIRS\par
2.3. Configure and Start Manager (in GGSCI on both hosts)\par
\par
GGSCI> EDIT PARAMS MGR\par
PORT 7809 # Or your chosen port\par
# Optional:\par
# DYNAMICPORTLIST 7810-7820\par
# AUTORESTART EXTRACT *, RETRIES 5, WAITMINUTES 3\par
# AUTORESTART REPLICAT *, RETRIES 5, WAITMINUTES 3\par
\par
GGSCI> START MGR\par
GGSCI> INFO MGR\par
3. GoldenGate Configuration on HostA (for DBA1)\par
3.1. DBLOGIN and Checkpoint Table\par
\par
GGSCI> DBLOGIN USERID gguser, PASSWORD GgUser123\par
GGSCI> ADD CHECKPOINTTABLE gguser.chkpt\par
3.2. Add Schema-level Supplemental Logging\par
\par
GGSCI> ADD SCHEMATRANDATA hr ALLCOLS\par
ALLCOLS is vital for COMPARECOLS and timestamp-based conflict resolution, ensuring all columns' before-images are captured.\par
3.3. Extract Process (Capturing from DBA1)\par
\par
Process Name: EXT_DBA1\par
Local Trail: ./dirdat/a1\par
Loop Prevention: TRANLOGOPTIONS EXCLUDEUSER gguser ensures this extract ignores transactions applied by the local Replicat.\par
GGSCI> EDIT PARAMS EXT_DBA1\par
EXTRACT EXT_DBA1\par
USERID gguser, PASSWORD GgUser123\par
EXTTRAIL ./dirdat/a1\par
DDL INCLUDE ALL\par
TRANLOGOPTIONS EXCLUDEUSER gguser\par
TABLE hr.employees, GETBEFORECOLS (ON UPDATE ALL, ON DELETE ALL);\par
\par
GGSCI> ADD EXTRACT EXT_DBA1, INTEGRATED TRANLOG, BEGIN NOW\par
GGSCI> ADD EXTTRAIL ./dirdat/a1, EXTRACT EXT_DBA1\par
3.4. Data Pump (Sending from DBA1 to DBA2)\par
\par
Process Name: DP_DBA1\par
Remote Host: HostB (IP address or hostname of DBA2 server)\par
Remote Trail: ./dirdat/b1 (trail file name on HostB for changes from DBA1)\par
GGSCI> EDIT PARAMS DP_DBA1\par
EXTRACT DP_DBA1\par
USERID gguser, PASSWORD GgUser123\par
RMTHOST HostB, MGRPORT 7809\par
RMTTRAIL ./dirdat/b1\par
PASSTHRU\par
TABLE hr.employees;\par
\par
GGSCI> ADD EXTRACT DP_DBA1, EXTTRAILSORUCE ./dirdat/a1\par
GGSCI> ADD RMTTRAIL ./dirdat/b1, EXTRACT DP_DBA1\par
3.5. Replicat Process (Applying from DBA2 to DBA1)\par
\par
Process Name: REP_DBA2_TO_DBA1\par
Source Remote Trail: ./dirdat/a2 (This trail file is generated by DP_DBA2 on HostB and received by the Manager on HostA)\par
Conflict Resolution:\par
INSERTROWEXISTS: If an insert from DBA2 tries to insert a row already existing on DBA1, USEMAX(LAST_UPDATE_TS) means the row with the newer last_update_ts value will win (the incoming one or the existing one).\par
UPDATEROWEXISTS: If an update from DBA2 conflicts with an update on DBA1, USEMAX(LAST_UPDATE_TS) applies the update from the transaction with the later timestamp.\par
UPDATEROWMISSING, DELETEROWMISSING: If a row doesn't exist for an update/delete, we discard the operation. This means DBA1 already removed the row or it never existed there.\par
DELETEROWEXISTS: If a delete conflicts, we can OVERWRITE (apply the delete).\par
GGSCI> EDIT PARAMS REP_DBA2_TO_DBA1\par
REPLICAT REP_DBA2_TO_DBA1\par
USERID gguser, PASSWORD GgUser123\par
ASSUMETARGETDEFS\par
DDL INCLUDE ALL\par
DDLOPTIONS REPORT, UPDATEMETADATA\par
CHECKPOINTTABLE gguser.chkpt\par
DISCARDFILE ./dirdsc/rep_dba2_to_dba1.dsc, APPEND, MEGABYTES 100\par
\par
MAP hr.employees, TARGET hr.employees,\par
-- Use the last_update_ts column for timestamp-based conflict resolution\par
RESOLVECONFLICT (INSERTROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TS))),\par
RESOLVECONFLICT (UPDATEROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TS))),\par
RESOLVECONFLICT (UPDATEROWMISSING, (DEFAULT, DISCARD)),\par
RESOLVECONFLICT (DELETEROWEXISTS, (DEFAULT, OVERWRITE)),\par
RESOLVECONFLICT (DELETEROWMISSING, (DEFAULT, DISCARD));\par
\par
GGSCI> ADD REPLICAT REP_DBA2_TO_DBA1, INTEGRATED, EXTTRAIL ./dirdat/a2, CHECKPOINTTABLE gguser.chkpt\par
4. GoldenGate Configuration on HostB (for DBA2)\par
The configuration on HostB will be symmetrical to HostA.\par
\par
4.1. DBLOGIN and Checkpoint Table\par
\par
GGSCI> DBLOGIN USERID gguser, PASSWORD GgUser123\par
GGSCI> ADD CHECKPOINTTABLE gguser.chkpt\par
4.2. Add Schema-level Supplemental Logging\par
\par
GGSCI> ADD SCHEMATRANDATA hr ALLCOLS\par
4.3. Extract Process (Capturing from DBA2)\par
\par
Process Name: EXT_DBA2\par
Local Trail: ./dirdat/b2\par
Loop Prevention: TRANLOGOPTIONS EXCLUDEUSER gguser\par
GGSCI> EDIT PARAMS EXT_DBA2\par
EXTRACT EXT_DBA2\par
USERID gguser, PASSWORD GgUser123\par
EXTTRAIL ./dirdat/b2\par
DDL INCLUDE ALL\par
TRANLOGOPTIONS EXCLUDEUSER gguser\par
TABLE hr.employees, GETBEFORECOLS (ON UPDATE ALL, ON DELETE ALL);\par
\par
GGSCI> ADD EXTRACT EXT_DBA2, INTEGRATED TRANLOG, BEGIN NOW\par
GGSCI> ADD EXTTRAIL ./dirdat/b2, EXTRACT EXT_DBA2\par
4.4. Data Pump (Sending from DBA2 to DBA1)\par
\par
Process Name: DP_DBA2\par
Remote Host: HostA\par
Remote Trail: ./dirdat/a2 (trail file name on HostA for changes from DBA2)\par
GGSCI> EDIT PARAMS DP_DBA2\par
EXTRACT DP_DBA2\par
USERID gguser, PASSWORD GgUser123\par
RMTHOST HostA, MGRPORT 7809\par
RMTTRAIL ./dirdat/a2\par
PASSTHRU\par
TABLE hr.employees;\par
\par
GGSCI> ADD EXTRACT DP_DBA2, EXTTRAILSORUCE ./dirdat/b2\par
GGSCI> ADD RMTTRAIL ./dirdat/a2, EXTRACT DP_DBA2\par
4.5. Replicat Process (Applying from DBA1 to DBA2)\par
\par
Process Name: REP_DBA1_TO_DBA2\par
Source Remote Trail: ./dirdat/b1 (from DP_DBA1 on HostA)\par
Conflict Resolution: Same logic as on HostA, using LAST_UPDATE_TS.\par
GGSCI> EDIT PARAMS REP_DBA1_TO_DBA2\par
REPLICAT REP_DBA1_TO_DBA2\par
USERID gguser, PASSWORD GgUser123\par
ASSUMETARGETDEFS\par
DDL INCLUDE ALL\par
DDLOPTIONS REPORT, UPDATEMETADATA\par
CHECKPOINTTABLE gguser.chkpt\par
DISCARDFILE ./dirdsc/rep_dba1_to_dba2.dsc, APPEND, MEGABYTES 100\par
\par
MAP hr.employees, TARGET hr.employees,\par
RESOLVECONFLICT (INSERTROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TS))),\par
RESOLVECONFLICT (UPDATEROWEXISTS, (DEFAULT, USEMAX(LAST_UPDATE_TS))),\par
RESOLVECONFLICT (UPDATEROWMISSING, (DEFAULT, DISCARD)),\par
RESOLVECONFLICT (DELETEROWEXISTS, (DEFAULT, OVERWRITE)),\par
RESOLVECONFLICT (DELETEROWMISSING, (DEFAULT, DISCARD));\par
\par
GGSCI> ADD REPLICAT REP_DBA1_TO_DBA2, INTEGRATED, EXTTRAIL ./dirdat/b1, CHECKPOINTTABLE gguser.chkpt\par
5. Start Processes (On both HostA and HostB)\par
On HostA:\par
\par
GGSCI> START EXTRACT EXT_DBA1\par
GGSCI> START EXTRACT DP_DBA1\par
GGSCI> START REPLICAT REP_DBA2_TO_DBA1\par
On HostB:\par
\par
GGSCI> START EXTRACT EXT_DBA2\par
GGSCI> START EXTRACT DP_DBA2\par
GGSCI> START REPLICAT REP_DBA1_TO_DBA2\par
Monitor:\par
\par
GGSCI> INFO ALL\par
GGSCI> STATS EXT_DBA1\par
GGSCI> STATS REP_DBA2_TO_DBA1\par
(and similarly for other processes on both hosts)\par
\par
6. Initial Data Synchronization (Crucial!)\par
Before starting the replication, ensure that HR.EMPLOYEES on DBA1 and DBA2 are identical. If they are not, you'll need to perform an initial data load. A common method is:\par
\par
Stop all GoldenGate processes on both sides.\par
Export data from one database (e.g., DBA1) using expdp.\par
Import data into the other database (DBA2) using impdp.\par
Restart all GoldenGate processes.\par
7. Testing\par
On DBA1 (as HR user):\par
\par
SQL\par
\par
INSERT INTO employees (employee_id, first_name, last_name, email, hire_date, job_id, salary)\par
VALUES (100, 'John', 'Doe', 'john.doe@example.com', SYSDATE, 'IT_PROG', 5000);\par
COMMIT;\par
\par
UPDATE employees SET salary = 5500 WHERE employee_id = 100;\par
COMMIT;\par
On DBA2 (as HR user):\par
Verify the changes:\par
\par
SQL\par
\par
SELECT employee_id, first_name, last_name, salary, last_update_ts FROM employees WHERE employee_id = 100;\par
You should see the updated salary.\par
\par
Now, try an update on DBA2:\par
\par
SQL\par
\par
UPDATE employees SET first_name = 'Johnny' WHERE employee_id = 100;\par
COMMIT;\par
On DBA1:\par
Verify the change:\par
\par
SQL\par
\par
SELECT employee_id, first_name, last_name, salary, last_update_ts FROM employees WHERE employee_id = 100;\par
first_name should now be 'Johnny'.\par
\par
Test a conflict (less predictable, but possible):\par
\par
Simultaneously (or very quickly) update the same row on both databases:\par
On DBA1: UPDATE employees SET salary = 6000 WHERE employee_id = 100; COMMIT;\par
On DBA2: UPDATE employees SET salary = 6500 WHERE employee_id = 100; COMMIT;\par
Observe which salary value persists (the one with the later LAST_UPDATE_TS will win based on our USEMAX rule). Check the report files and discard files for conflict messages.\cf2\par
\par
\par
\par
\par
\par
\par
}
 